---
title: '프론트엔드 역사와 미래'
date: 2023/12/07
---

## 1. 프론트엔드의 탄생과 현재, 미래

### 1.1 Web 1.0 (1990~2000초)

- 1990, 웹이 탄생 (HTML, HTTP)
- 1994, 동적 페이지 탄생, CGI(Common Gate Interface), (e.g. PHP)
- 1995, JavaScript 탄생, 동작 제어
- 1996, CSS 탄생, 브라우저 애니메이션용 Flash 탄생
- 구글 검색 엔진, MS의 Explorer 대중화, e-커머스 등의 `닷컴 열풍`

---

### 1.2 Web 2.0

- 2001년, 닷컴버블로 IT 산업의 거품이 꺼짐
- 2000년 초, 애플의 Flash 퇴출 운동
- 2005년, 구글의 크롬 브라우저(V8 엔진)와 Map으로 Ajax(비동기)의 등장
  - 백엔드와 프론트엔드의 전문성을 분리(프론트엔드의 탄생)
- 크로스 브라우저 호환성을 위해 웹 표준이 등장
- DOM을 쉽게 쓰기 위해 jQuery가 등장
- 2009년, V8엔진 기반 Node.js와 npm 등장
- SPA 프레임워크인 구글 Angular가 등장
- 2013년, 페이스북에서 Angular가 너무 무거워서 라이브러리인 React 등장
- 2015년, 페이스북의 크로스 플랫폼을 위한 React Native 등장
- 미래, serverless하게?

---

### 1.3 Web 3.0

- 블록체인 기반의 탈중앙화된 인터넷(e.g. 비트코인)

---

### 1.4 프론트엔드 포지션에 대한 이해

일반적으로 프론트엔드가 하는 업무는 크게 4가지로 구분 가능하다.

1. 데이터를 (예쁘게) 잘 보여주기
2. 데이터(화면)를 조작하기
3. 서버로 데이터를 보내기
4. 서버에서 받은 데이터를 다루기

회사나 프로젝트의 특성에 따라서 사용자에 가까운 쪽을 만드느냐
백엔드랑 가까운 쪽을 맡게 되느냐에 따라서 해야 하는 주 업무의 모양새가 좀 달라진다.

- 퍼블리셔는 대개 1~2의 영역만을 다루고,
- 백엔드는 3~4의 영역만 다루는 것이 일반적인 견해다.

`프론트엔드가 1~2~3~4를 혼자서 다하는가?`라고 하면 꼭 그렇지는 않고,
프론트 개발자마다 주력 포지션이 `1~2~3~4` 어딘가에 있다.
이를 칼 같이 구분할 수는 없지만, 회사마다 경계선은 존재한다.
왜냐하면 프론트엔드가 없다가 갑자기 튀어나온 게 아니라, 웹이 커져가면서 기존 역할을 분리하면서 생겼기 때문이다.

- `코딩만 잘하는 개발자 !== 잘하는 개발자`
- `(코딩 + 시간 잘맞추고 + 협업 잘하는 개발자) === 잘하는 개발자`

프론트엔드의 기술적인 가치는 안타깝게도 엄청 중요하지는 않다.
대부분의 서비스들이 화면이 좀 안보여도, 사업은 돌아는 가기 때문에.
그래서 일반적으로 일정을 잘 지키는 개발자가 좋은 개발자라고 생각한다.
보통 주니어를 벗어났는가를 구분하는 주요 기준으로 일정을 컨트롤할 수 있는지 여부를 본다.

근데 `기획 -> 디자인 -> 백앤드 -> 프론트엔드`의 개발 일정순서에서
다른 포지션과 협업을 많이 하고, 모든 작업의 마지막에서 마무리를 하기에 일정 산출이 어렵다.
그래서 일정 산출을 잘하려면, 다른 포지션에 대한 이해와 지식이 풍부해야 한다.

기획, 디자인, 백엔드, QA, UX, 사업, 사용자까지 협업 라인까지 타 지식을 열심히 쌓아야 한다.
또한 소통의 방식으로 말과 글이 있다. 회사의 규모가 커질 수록 문서의 중요도가 높아진다.
말로 끝나면 시간이 지나면 잊어버리고, 담당자가 퇴사하면 답이 없다.
문서를 잘 쓰는 것은 중요한 능력이고, 이때문에 개발자 취업에서 블로그를 보는 것이다.

---

### 1.5 참고

- https://yozm.wishket.com/magazine/detail/1289/

---

## 2. 프론트엔드 아키텍쳐의 역사

1. HTML, CSS, JS의 탄생: 관심의 분리와 느슨한 결합
2. jQuery까지의 시대: DOM을 쉽게 쓰자
3. HTML + JS를 합치자: `MVC 컴포넌트 방식`의 탄생
   - MVC 패턴으로 만들려고하는 backbon.js 프레임워크가 등장
4. 데이터 바인딩 + 템플릿 = `MVVM 웹 프레임워크`
   - knockout.js와 angular 등의 등장으로 MVVM 아키텍쳐가 등장
   - 이후 React, Vue, Angular로 3대장으로 정착
5. `Container - Presenter 방식` : 컴포넌트 간 데이터 교환이 너무 복잡
   - 데이터 조작을 다루는 `Container 컴포넌트`
   - 뷰를 보여주는 `Presenter 컴포넌트`
   - Container에서 props를 Presenter로 내려주면서 로직을 한군데에 모으고,
   - 화면을 다루는 View 방식이 재사용 형태의 아키텍처 주류가 됨
6. `Flux 패턴과 Redux` : Props Drill 문제 대두
   - 상위 props들을 하위 컴포넌트로 전달할 때,
   - 중간 컴포넌트에서 사용하지 않는 props를 추가해야 하는 Props Driling 문제가 대두됨
   - 이에, 비즈니스 로직을 컴포넌트 계층구조가 아닌,
     - View와 비즈니스 로직을 분리해 단방향 데이터 구조를 가지는 Flux 패턴이 등장
   - Redux 등을 통해 FLux 패턴이 주류가 됨
   - 이렇게 비즈니스 로직을 컴포넌트에서 분리하고, 별도로 관리하는 도구들이 등장
     - 이 도구들을 `상태관리(State Management)`라고 부름
     - e.g. Redux, Vuex(vue진영), Mobx(클래스 데코레이터로 좀 더 쉽게 사용)
7. `Hooks 패턴과 Context, Recoil, Zustand, jotai` : Redux 너무 복잡하다. 쉽게 가자
   - Redux는 너무 많은 보일러플레이트(여러 곳에서 재사용되며, 반복적으로 비슷한 형태를 띠는 코드)가 필요
   - React 팀에서 Hooks를 통해 외부 비즈니스 로직을 쉽게 연동함
     - Context를 통해 Props Driling 없이도 상위 Props를 하위 컴포넌트로 전달 가능해짐
   - React 팀에서 Hook API만으로 전역 상태관리가 한계가 있었음
     - 그래서 Atom이라 불리는 전역 객체를 이용해 데이터를 기록하고,
     - 변경감지를 통해 View로 전달하는 형태의 `상태관리 도구`들이 등장
     - e.g. Recoil, Zustands, Jotai
     - cf. Redux 팀도 Redux 버리고, Redux toolkit이라는 상태관리 도구를 쓰길 권장
8. `React Query, SWR, Redux Query` : 서버 API 관리 도구
   - 프론트엔드에서 전역 상태 관리가 필요한 이유? 서버와 API떄문
   - 웹의 데이터는 CRUD는 서버에서 이루어지고, 비즈니스 로직이 대부분 백엔드에 보관됨
   - 그래서 View는 서버 데이터 보여주고, 서버에 Action을 전달만 하는 도구가 등장
     - 백엔드와 직접 연동해 로딩, 캐싱, 무효화, 업데이트 로직을 단순화
     - 이로 인해 API를 통한 전역 상태 관리가 단순해짐
9. 기타...
   - 연산자, 함수를 그래도 사용해 로컬에서 데이터 변경감지하는 전력 관리 기능 도구
     - React의 Valtio 라이브러리
   - 기존 상태관리 도구들의 단점인 복잡한 상용구와 중첩 객체를 쉽게 풀어낸 도구
     - Hookstate 라이브러리

---

### 2.1 프론트엔드에서 MV\* 아키텍쳐

1. `순수 MVC 아키텍쳐`
   - `Model(데이터)` : (e.g. JS Obejct, 서버 API, 서버에 있는 DB 등)
   - `View(화면)` : HTML, CSS
   - `Controller(컨트롤러)` : Model, View 사이의 중간자 역할
   - 초창기 웹은 DB를 Model로 보고,
   - HTML, CSS, JS를 View로 보고,
   - 라우터를 통해 새 HTML을 보여주는 백앤드 영역을 Controller라 취급
   - PHP, JSP 등
2. `jQuery MVC 아키텍쳐`
   - ajax로 받는 데이터를 Model로 보고,
   - HTML, CSS를 View로 보고,
   - JS가 중간에서 서버 데이터 받아서 이벤트 처리하고 서버에 데이터 전달하는 Controller 역할
3. `MVVM 아키텍쳐`
   - jQuery의 문제점 :
     - 데이터를 찾고, 수정, 이벤트 연결, 수정 등 반복적인 패턴을 발견
     - `{{ }}, <?= ?>, <%= %>`와 같은 치환자로 개발, but 수정할 부분을 일일히 찾아야 함
   - 2013년 angualar.js가 나와 `템플릿`과 `바인딩` 개념이 등장
   - Controller의 역할을 기존 jQuery DOM 조작방식에서 템플릿과 바인딩을 통한 선언적 방법으로 변경됨
   - `Model`은 그대로 데이터 관련
   - `View`도 그대로 HTML, CSS
   - Controller는 View를 그리는 Model만 다루게 되었다는 의미로 `ViewModel`로 변경
   - 이를 MVVM 아키텍쳐라고 부르며 React, Vue, Angualar2, Svelte 등이 존재
   - 위 4개의 라이브러리(프레임워크)들 모두 템플릿과 바인딩 문법을 쓰는 방식이 다를 뿐 똑같음
4. `Flux 아키텍쳐`
   - MVC 기반이 아닌 단방향 패턴 (Action > Dispatcher > Store > View)
     - `View(사용자가 클릭한거)`에서 `Action(이벤트 같은거)` 호출,
     - `Dispatcher(배달하는 놈)`를 통해 `Store(저장소)`에 데이터 보관,
     - Store에서 다시 View로 전달
   - Flux 패턴 구현 라이브러리 Redux 등장
   - Flux 아키텍쳐 단점
     - 너무 많은 보일러 플레이트로 인해 문법이 장황함
     - 위 이유로 학습하기 어려움
5. `MVI 아키텍쳐`
   - 기존 Flux 패턴의 Dispatch, Action과 Update 인터페이스를 전부
   - Observable를 이용한 `스트림(Stream) 방식`으로 비동기 문제를 해결
   - 현재 ios와 android의 새 아키텍쳐로 부상 중
     - 단방향 아키텍쳐
     - 선언적 프로그래밍을 통한 Controller
     - 뷰와 비지니스 로직의 분리(상태관리)
     - 반응형 프로그래밍
     - 서버와의 연동을 Controller로 간주하는 움직임
6. 현대 아키텍쳐들은 크게 4방향으로 발전 중
   1. Context와 hook, props 상속
      - Redux 너무 복잡하니 쓰지말자.
      - Props Driling이 문제면, Props만 새로 뚫지 않는 방법을 제공하자.
      - 그래서 React 기본 기능인 Context API 쓰자
   2. Atomic 패턴 - Recoil, jotai, Vue Composition, Svelte Store
      - Action ~ Dispatch ~ Reducer와 같은 복잡한 구조를 없애보자
      - 컴포넌트 외부에서 공통의 데이터를 set, get을 하면서 동시에 동기화
        - View와 Model은 분리
        - 중간의 과정은 자율에 맡기고 간단하게 Model에 접근법만 알자
        - 동기화, 동시성 처리가 중요
   3. React-Query, SWR(MVC의 개념 확대)
      - Model : 서버와 fetch
      - View : React
      - Controller : query와 mutation이란 2가지 인터페이스를 통해 서버 상태 관리
      - 캐싱, 동기화, refetch 등을 관리
   4. GrahphQL, firebase - Schema Based 아키텍쳐
      - 먼저 스키마를 정의하고, 스키마 기반으로 데이터 교환
      - Model : 서버 데이터
      - View : React
      - Controller : query와 mutation 통신을 통해 view에게 데이터를 전달하는 방식

어떤 것이든 칼 같이 딱 떨어지지 않는다.
왜냐면 만든 사람들이 다른 것들을 보고 참고해서 계속 발전시키기 떄문...
무슨 `MV*` 뭐시기든 저시기든, 결국 Model과 View 사이에 무언가를 조정하는 것이다.

---

### 2.2 참고

- https://yozm.wishket.com/magazine/detail/1663/
- https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-MV-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94
